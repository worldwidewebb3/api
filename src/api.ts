/* tslint:disable */
/* eslint-disable */
/**
 * Worldwide Webb Public API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.21
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnonymousSchema12
 */
export interface AnonymousSchema12 {
}
/**
 * 
 * @export
 * @interface AnonymousSchema51
 */
export interface AnonymousSchema51 {
}
/**
 * 
 * @export
 * @interface AppInfo
 */
export interface AppInfo {
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ItemNameAndQuantity
 */
export interface ItemNameAndQuantity {
    /**
     * 
     * @type {string}
     * @memberof ItemNameAndQuantity
     */
    'itemName': string;
    /**
     * 
     * @type {number}
     * @memberof ItemNameAndQuantity
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface NftsAnonymousSchema24
 */
export interface NftsAnonymousSchema24 {
}
/**
 * 
 * @export
 * @interface NftsNftAvatar
 */
export interface NftsNftAvatar {
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'nftAvatarId': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'nftCollectionId': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'collectionAddressPair': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'tokenId': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'tokenName': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'description'?: string;
    /**
     * 
     * @type {Spritesheet}
     * @memberof NftsNftAvatar
     */
    'spritesheet': Spritesheet;
    /**
     * 
     * @type {boolean}
     * @memberof NftsNftAvatar
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NftsNftAvatar
     */
    'collectionTypes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'thumbnailUri': string;
    /**
     * 
     * @type {string}
     * @memberof NftsNftAvatar
     */
    'url': string;
    /**
     * 
     * @type {NftsAnonymousSchema24}
     * @memberof NftsNftAvatar
     */
    'metadata'?: NftsAnonymousSchema24;
    /**
     * 
     * @type {number}
     * @memberof NftsNftAvatar
     */
    'pipelineSequence'?: number;
}
/**
 * 
 * @export
 * @interface PublicProfile
 */
export interface PublicProfile {
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'displayName': string;
    /**
     * 
     * @type {number}
     * @memberof PublicProfile
     */
    'displayNameColor'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'userType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicProfile
     */
    'isBanned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicProfile
     */
    'isChatBanned'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicProfile
     */
    'isTradeBanned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'nftAvatarId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicProfile
     */
    'isGuest': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicProfile
     */
    'featureFlags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ScoreEntry
 */
export interface ScoreEntry {
    /**
     * 
     * @type {string}
     * @memberof ScoreEntry
     */
    'scoreId': string;
    /**
     * 
     * @type {string}
     * @memberof ScoreEntry
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof ScoreEntry
     */
    'appMode': string;
    /**
     * 
     * @type {Array<ScoreUser>}
     * @memberof ScoreEntry
     */
    'users': Array<ScoreUser>;
    /**
     * 
     * @type {number}
     * @memberof ScoreEntry
     */
    'score': number;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreEntry
     */
    'highestScore'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreEntry
     */
    'lowestScore'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreEntry
     */
    'dailyHighestScore'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreEntry
     */
    'dailyLowestScore'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScoreEntry
     */
    'rank'?: number;
}
/**
 * 
 * @export
 * @interface ScoreUser
 */
export interface ScoreUser {
    /**
     * 
     * @type {string}
     * @memberof ScoreUser
     */
    'memberId': string;
    /**
     * 
     * @type {string}
     * @memberof ScoreUser
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ScoreUser
     */
    'nftAvatarId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreUser
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface SearchTextRequest
 */
export interface SearchTextRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchTextRequest
     */
    'searchText': string;
}
/**
 * 
 * @export
 * @interface SessionMemberWithAvatar
 */
export interface SessionMemberWithAvatar {
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'nftAvatarId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionMemberWithAvatar
     */
    'receiveReward'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionMemberWithAvatar
     */
    'complete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'sessionResult'?: string;
    /**
     * 
     * @type {Array<ItemNameAndQuantity>}
     * @memberof SessionMemberWithAvatar
     */
    'itemNamesAndQuantities'?: Array<ItemNameAndQuantity>;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'status'?: string;
    /**
     * 
     * @type {SessionsAnonymousSchema24}
     * @memberof SessionMemberWithAvatar
     */
    'data'?: SessionsAnonymousSchema24;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithAvatar
     */
    'memberId': string;
    /**
     * 
     * @type {SessionsNftAvatar}
     * @memberof SessionMemberWithAvatar
     */
    'nftAvatar'?: SessionsNftAvatar;
}
/**
 * 
 * @export
 * @interface SessionMemberWithId
 */
export interface SessionMemberWithId {
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'nftAvatarId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionMemberWithId
     */
    'receiveReward'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionMemberWithId
     */
    'complete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'sessionResult'?: string;
    /**
     * 
     * @type {Array<ItemNameAndQuantity>}
     * @memberof SessionMemberWithId
     */
    'itemNamesAndQuantities'?: Array<ItemNameAndQuantity>;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'status'?: string;
    /**
     * 
     * @type {SessionsAnonymousSchema24}
     * @memberof SessionMemberWithId
     */
    'data'?: SessionsAnonymousSchema24;
    /**
     * 
     * @type {string}
     * @memberof SessionMemberWithId
     */
    'memberId': string;
}
/**
 * 
 * @export
 * @interface SessionResult
 */
export interface SessionResult {
    /**
     * 
     * @type {string}
     * @memberof SessionResult
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResult
     */
    'memberId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResult
     */
    'url': string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionResult
     */
    'complete'?: boolean;
}
/**
 * 
 * @export
 * @interface SessionWithId
 */
export interface SessionWithId {
    /**
     * 
     * @type {string}
     * @memberof SessionWithId
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionWithId
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionWithId
     */
    'appMode': string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionWithId
     */
    'closed': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionWithId
     */
    'memberIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SessionWithId
     */
    'status'?: string;
    /**
     * 
     * @type {AnonymousSchema12}
     * @memberof SessionWithId
     */
    'data'?: AnonymousSchema12;
}
/**
 * 
 * @export
 * @interface SessionsAnonymousSchema24
 */
export interface SessionsAnonymousSchema24 {
}
/**
 * 
 * @export
 * @interface SessionsGetMember200Response
 */
export interface SessionsGetMember200Response {
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'nftAvatarId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionsGetMember200Response
     */
    'receiveReward'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionsGetMember200Response
     */
    'complete'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'sessionResult'?: string;
    /**
     * 
     * @type {Array<ItemNameAndQuantity>}
     * @memberof SessionsGetMember200Response
     */
    'itemNamesAndQuantities'?: Array<ItemNameAndQuantity>;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'status'?: string;
    /**
     * 
     * @type {SessionsAnonymousSchema24}
     * @memberof SessionsGetMember200Response
     */
    'data'?: SessionsAnonymousSchema24;
    /**
     * 
     * @type {string}
     * @memberof SessionsGetMember200Response
     */
    'memberId': string;
    /**
     * 
     * @type {SessionsNftAvatar}
     * @memberof SessionsGetMember200Response
     */
    'nftAvatar'?: SessionsNftAvatar;
}
/**
 * 
 * @export
 * @interface SessionsGetMembers200Response
 */
export interface SessionsGetMembers200Response {
}
/**
 * 
 * @export
 * @interface SessionsNftAvatar
 */
export interface SessionsNftAvatar {
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'nftAvatarId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'nftCollectionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'collectionAddressPair': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'tokenId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'tokenName': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'description'?: string;
    /**
     * 
     * @type {Spritesheet}
     * @memberof SessionsNftAvatar
     */
    'spritesheet': Spritesheet;
    /**
     * 
     * @type {boolean}
     * @memberof SessionsNftAvatar
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof SessionsNftAvatar
     */
    'collectionTypes': Array<any>;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'thumbnailUri': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsNftAvatar
     */
    'url': string;
    /**
     * 
     * @type {AnonymousSchema51}
     * @memberof SessionsNftAvatar
     */
    'metadata'?: AnonymousSchema51;
    /**
     * 
     * @type {number}
     * @memberof SessionsNftAvatar
     */
    'pipelineSequence'?: number;
}
/**
 * 
 * @export
 * @interface Spritesheet
 */
export interface Spritesheet {
    /**
     * 
     * @type {string}
     * @memberof Spritesheet
     */
    'imageUri': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Spritesheet
     */
    'frameSize': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Spritesheet
     */
    'frameOrigin': Array<number>;
    /**
     * 
     * @type {Array<SpritesheetFrame>}
     * @memberof Spritesheet
     */
    'frames': Array<SpritesheetFrame>;
    /**
     * 
     * @type {string}
     * @memberof Spritesheet
     */
    'walkType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Spritesheet
     */
    'idleType'?: string;
    /**
     * 
     * @type {number}
     * @memberof Spritesheet
     */
    'scale': number;
}
/**
 * 
 * @export
 * @interface SpritesheetFrame
 */
export interface SpritesheetFrame {
    /**
     * 
     * @type {string}
     * @memberof SpritesheetFrame
     */
    'frameType': string;
    /**
     * 
     * @type {number}
     * @memberof SpritesheetFrame
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof SpritesheetFrame
     */
    'frameSpeed': number;
}
/**
 * 
 * @export
 * @interface UserEloProfile
 */
export interface UserEloProfile {
    /**
     * 
     * @type {string}
     * @memberof UserEloProfile
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEloProfile
     */
    'gameMode': string;
    /**
     * 
     * @type {number}
     * @memberof UserEloProfile
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof UserEloProfile
     */
    'recentChange'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserEloProfile
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserEloProfile
     */
    'rank'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserEloProfile
     */
    'nftAvatarId'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the public profile of a user based on their User ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGetUserPublicProfile: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authGetUserPublicProfile', 'userId', userId)
            const localVarPath = `/auth/users/{userId}/public`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the server timestamp in milliseconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTimestamp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/auth/timestamp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches the public profile of a user based on their User ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGetUserPublicProfile(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGetUserPublicProfile(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the server timestamp in milliseconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTimestamp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTimestamp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Fetches the public profile of a user based on their User ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGetUserPublicProfile(userId: string, options?: any): AxiosPromise<PublicProfile> {
            return localVarFp.authGetUserPublicProfile(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the server timestamp in milliseconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTimestamp(options?: any): AxiosPromise<number> {
            return localVarFp.authTimestamp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Fetches the public profile of a user based on their User ID
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGetUserPublicProfile(userId: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGetUserPublicProfile(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the server timestamp in milliseconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTimestamp(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTimestamp(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthAdminApi - axios parameter creator
 * @export
 */
export const AuthAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SearchTextRequest} searchTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSearchUsersByDisplayName: async (searchTextRequest: SearchTextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTextRequest' is not null or undefined
            assertParamExists('authSearchUsersByDisplayName', 'searchTextRequest', searchTextRequest)
            const localVarPath = `/auth/admin/user_search_by_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchTextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthAdminApi - functional programming interface
 * @export
 */
export const AuthAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SearchTextRequest} searchTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSearchUsersByDisplayName(searchTextRequest: SearchTextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSearchUsersByDisplayName(searchTextRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthAdminApi - factory interface
 * @export
 */
export const AuthAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthAdminApiFp(configuration)
    return {
        /**
         * 
         * @param {SearchTextRequest} searchTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSearchUsersByDisplayName(searchTextRequest: SearchTextRequest, options?: any): AxiosPromise<object> {
            return localVarFp.authSearchUsersByDisplayName(searchTextRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthAdminApi - object-oriented interface
 * @export
 * @class AuthAdminApi
 * @extends {BaseAPI}
 */
export class AuthAdminApi extends BaseAPI {
    /**
     * 
     * @param {SearchTextRequest} searchTextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthAdminApi
     */
    public authSearchUsersByDisplayName(searchTextRequest: SearchTextRequest, options?: AxiosRequestConfig) {
        return AuthAdminApiFp(this.configuration).authSearchUsersByDisplayName(searchTextRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchApi - axios parameter creator
 * @export
 */
export const MatchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetActiveMatches: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions/matches/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetLatestMatchIds: async (userId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions/matches/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMatch: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sessionsGetMatch', 'sessionId', sessionId)
            const localVarPath = `/sessions/matches/match/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchApi - functional programming interface
 * @export
 */
export const MatchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetActiveMatches(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetActiveMatches(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetLatestMatchIds(userId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetLatestMatchIds(userId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetMatch(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetMatch(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchApi - factory interface
 * @export
 */
export const MatchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetActiveMatches(options?: any): AxiosPromise<any> {
            return localVarFp.sessionsGetActiveMatches(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetLatestMatchIds(userId?: string, limit?: number, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.sessionsGetLatestMatchIds(userId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMatch(sessionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.sessionsGetMatch(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchApi - object-oriented interface
 * @export
 * @class MatchApi
 * @extends {BaseAPI}
 */
export class MatchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public sessionsGetActiveMatches(options?: AxiosRequestConfig) {
        return MatchApiFp(this.configuration).sessionsGetActiveMatches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public sessionsGetLatestMatchIds(userId?: string, limit?: number, options?: AxiosRequestConfig) {
        return MatchApiFp(this.configuration).sessionsGetLatestMatchIds(userId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public sessionsGetMatch(sessionId: string, options?: AxiosRequestConfig) {
        return MatchApiFp(this.configuration).sessionsGetMatch(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NftApi - axios parameter creator
 * @export
 */
export const NftApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatar: async (nftAvatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nftAvatarId' is not null or undefined
            assertParamExists('nftsGetNftAvatar', 'nftAvatarId', nftAvatarId)
            const localVarPath = `/nfts/nft_avatars/{nftAvatarId}`
                .replace(`{${"nftAvatarId"}}`, encodeURIComponent(String(nftAvatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatarThumbnail: async (nftAvatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nftAvatarId' is not null or undefined
            assertParamExists('nftsGetNftAvatarThumbnail', 'nftAvatarId', nftAvatarId)
            const localVarPath = `/nfts/nft_avatars/{nftAvatarId}/thumbnail`
                .replace(`{${"nftAvatarId"}}`, encodeURIComponent(String(nftAvatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NftApi - functional programming interface
 * @export
 */
export const NftApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NftApiAxiosParamCreator(configuration)
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftsGetNftAvatar(nftAvatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftsNftAvatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftsGetNftAvatar(nftAvatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftsGetNftAvatarThumbnail(nftAvatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NftApi - factory interface
 * @export
 */
export const NftApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NftApiFp(configuration)
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatar(nftAvatarId: string, options?: any): AxiosPromise<NftsNftAvatar> {
            return localVarFp.nftsGetNftAvatar(nftAvatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: any): AxiosPromise<string> {
            return localVarFp.nftsGetNftAvatarThumbnail(nftAvatarId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NftApi - object-oriented interface
 * @export
 * @class NftApi
 * @extends {BaseAPI}
 */
export class NftApi extends BaseAPI {
    /**
     * Get avatar
     * @param {string} nftAvatarId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftApi
     */
    public nftsGetNftAvatar(nftAvatarId: string, options?: AxiosRequestConfig) {
        return NftApiFp(this.configuration).nftsGetNftAvatar(nftAvatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get avatar thumbnail
     * @param {string} nftAvatarId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftApi
     */
    public nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: AxiosRequestConfig) {
        return NftApiFp(this.configuration).nftsGetNftAvatarThumbnail(nftAvatarId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NftAvatarApi - axios parameter creator
 * @export
 */
export const NftAvatarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatar: async (nftAvatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nftAvatarId' is not null or undefined
            assertParamExists('nftsGetNftAvatar', 'nftAvatarId', nftAvatarId)
            const localVarPath = `/nfts/nft_avatars/{nftAvatarId}`
                .replace(`{${"nftAvatarId"}}`, encodeURIComponent(String(nftAvatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatarThumbnail: async (nftAvatarId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nftAvatarId' is not null or undefined
            assertParamExists('nftsGetNftAvatarThumbnail', 'nftAvatarId', nftAvatarId)
            const localVarPath = `/nfts/nft_avatars/{nftAvatarId}/thumbnail`
                .replace(`{${"nftAvatarId"}}`, encodeURIComponent(String(nftAvatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NftAvatarApi - functional programming interface
 * @export
 */
export const NftAvatarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NftAvatarApiAxiosParamCreator(configuration)
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftsGetNftAvatar(nftAvatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NftsNftAvatar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftsGetNftAvatar(nftAvatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftsGetNftAvatarThumbnail(nftAvatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NftAvatarApi - factory interface
 * @export
 */
export const NftAvatarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NftAvatarApiFp(configuration)
    return {
        /**
         * Get avatar
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatar(nftAvatarId: string, options?: any): AxiosPromise<NftsNftAvatar> {
            return localVarFp.nftsGetNftAvatar(nftAvatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get avatar thumbnail
         * @param {string} nftAvatarId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: any): AxiosPromise<string> {
            return localVarFp.nftsGetNftAvatarThumbnail(nftAvatarId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NftAvatarApi - object-oriented interface
 * @export
 * @class NftAvatarApi
 * @extends {BaseAPI}
 */
export class NftAvatarApi extends BaseAPI {
    /**
     * Get avatar
     * @param {string} nftAvatarId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftAvatarApi
     */
    public nftsGetNftAvatar(nftAvatarId: string, options?: AxiosRequestConfig) {
        return NftAvatarApiFp(this.configuration).nftsGetNftAvatar(nftAvatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get avatar thumbnail
     * @param {string} nftAvatarId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftAvatarApi
     */
    public nftsGetNftAvatarThumbnail(nftAvatarId: string, options?: AxiosRequestConfig) {
        return NftAvatarApiFp(this.configuration).nftsGetNftAvatarThumbnail(nftAvatarId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RankingApi - axios parameter creator
 * @export
 */
export const RankingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetClosestEloRanks: async (gameMode: string, userId: string, numberOfRanks?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMode' is not null or undefined
            assertParamExists('rankingGetClosestEloRanks', 'gameMode', gameMode)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rankingGetClosestEloRanks', 'userId', userId)
            const localVarPath = `/ranking/elo_ranking/modes/{gameMode}/users/{userId}/closest`
                .replace(`{${"gameMode"}}`, encodeURIComponent(String(gameMode)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfRanks !== undefined) {
                localVarQueryParameter['numberOfRanks'] = numberOfRanks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetClosestScores: async (appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('rankingGetClosestScores', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('rankingGetClosestScores', 'appModeId', appModeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rankingGetClosestScores', 'userId', userId)
            const localVarPath = `/ranking/ranking/{appId}/modes/{appModeId}/users/{userId}/closest`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetTopEloRanks: async (gameMode: string, numberOfRanks?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMode' is not null or undefined
            assertParamExists('rankingGetTopEloRanks', 'gameMode', gameMode)
            const localVarPath = `/ranking/elo_ranking/modes/{gameMode}/top`
                .replace(`{${"gameMode"}}`, encodeURIComponent(String(gameMode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfRanks !== undefined) {
                localVarQueryParameter['numberOfRanks'] = numberOfRanks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetUserEloRank: async (gameMode: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameMode' is not null or undefined
            assertParamExists('rankingGetUserEloRank', 'gameMode', gameMode)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rankingGetUserEloRank', 'userId', userId)
            const localVarPath = `/ranking/elo_ranking/modes/{gameMode}/users/{userId}`
                .replace(`{${"gameMode"}}`, encodeURIComponent(String(gameMode)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingApi - functional programming interface
 * @export
 */
export const RankingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RankingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingGetClosestEloRanks(gameMode: string, userId: string, numberOfRanks?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserEloProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingGetClosestEloRanks(gameMode, userId, numberOfRanks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingGetClosestScores(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingGetClosestScores(appId, appModeId, userId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingGetTopEloRanks(gameMode: string, numberOfRanks?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserEloProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingGetTopEloRanks(gameMode, numberOfRanks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rankingGetUserEloRank(gameMode: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEloProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rankingGetUserEloRank(gameMode, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RankingApi - factory interface
 * @export
 */
export const RankingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RankingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetClosestEloRanks(gameMode: string, userId: string, numberOfRanks?: number, options?: any): AxiosPromise<Array<UserEloProfile>> {
            return localVarFp.rankingGetClosestEloRanks(gameMode, userId, numberOfRanks, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetClosestScores(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.rankingGetClosestScores(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {number} [numberOfRanks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetTopEloRanks(gameMode: string, numberOfRanks?: number, options?: any): AxiosPromise<Array<UserEloProfile>> {
            return localVarFp.rankingGetTopEloRanks(gameMode, numberOfRanks, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameMode 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankingGetUserEloRank(gameMode: string, userId: string, options?: any): AxiosPromise<UserEloProfile> {
            return localVarFp.rankingGetUserEloRank(gameMode, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RankingApi - object-oriented interface
 * @export
 * @class RankingApi
 * @extends {BaseAPI}
 */
export class RankingApi extends BaseAPI {
    /**
     * 
     * @param {string} gameMode 
     * @param {string} userId 
     * @param {number} [numberOfRanks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingGetClosestEloRanks(gameMode: string, userId: string, numberOfRanks?: number, options?: AxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingGetClosestEloRanks(gameMode, userId, numberOfRanks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {string} userId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingGetClosestScores(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingGetClosestScores(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameMode 
     * @param {number} [numberOfRanks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingGetTopEloRanks(gameMode: string, numberOfRanks?: number, options?: AxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingGetTopEloRanks(gameMode, numberOfRanks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameMode 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingApi
     */
    public rankingGetUserEloRank(gameMode: string, userId: string, options?: AxiosRequestConfig) {
        return RankingApiFp(this.configuration).rankingGetUserEloRank(gameMode, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetDailyGameModeScores: async (appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetDailyGameModeScores', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetDailyGameModeScores', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/daily`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {boolean} [validated] 
         * @param {number} [fetchExtraScores] 
         * @param {number} [killsGreaterThan] 
         * @param {string} [startDateTime] 
         * @param {string} [endDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScoreRanked: async (appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, validated?: boolean, fetchExtraScores?: number, killsGreaterThan?: number, startDateTime?: string, endDateTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScoreRanked', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScoreRanked', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/ranked`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }

            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }

            if (fetchExtraScores !== undefined) {
                localVarQueryParameter['fetchExtraScores'] = fetchExtraScores;
            }

            if (killsGreaterThan !== undefined) {
                localVarQueryParameter['killsGreaterThan'] = killsGreaterThan;
            }

            if (startDateTime !== undefined) {
                localVarQueryParameter['startDateTime'] = startDateTime;
            }

            if (endDateTime !== undefined) {
                localVarQueryParameter['endDateTime'] = endDateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScores: async (appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScores', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScores', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {number} [threshold] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScoresAll: async (appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, threshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScoresAll', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetGameModeScoresAll', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/all`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }

            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetInfo: async (appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetInfo', 'appId', appId)
            const localVarPath = `/sessions/apps/{appId}/info`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [allowClosed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetSessions: async (appId: string, appModeId: string, allowClosed?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetSessions', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetSessions', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/sessions`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (allowClosed !== undefined) {
                localVarQueryParameter['allowClosed'] = allowClosed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersDailyGameModeScore: async (appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetUsersDailyGameModeScore', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetUsersDailyGameModeScore', 'appModeId', appModeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sessionsAppGetUsersDailyGameModeScore', 'userId', userId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/daily/users/{userId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScore: async (appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScore', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScore', 'appModeId', appModeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScore', 'userId', userId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/users/{userId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScoreRanked: async (appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScoreRanked', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScoreRanked', 'appModeId', appModeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScoreRanked', 'userId', userId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/users/{userId}/ranked`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (numberOfScores !== undefined) {
                localVarQueryParameter['numberOfScores'] = numberOfScores;
            }

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScoresDaily: async (appId: string, appModeId: string, golf?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScoresDaily', 'appId', appId)
            // verify required parameter 'appModeId' is not null or undefined
            assertParamExists('sessionsAppGetUsersGameModeScoresDaily', 'appModeId', appModeId)
            const localVarPath = `/sessions/apps/{appId}/modes/{appModeId}/scores/daily/all`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"appModeId"}}`, encodeURIComponent(String(appModeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (golf !== undefined) {
                localVarQueryParameter['golf'] = golf;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMember: async (sessionId: string, memberId: string, withAvatar?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sessionsGetMember', 'sessionId', sessionId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('sessionsGetMember', 'memberId', memberId)
            const localVarPath = `/sessions/sessions/{sessionId}/members/{memberId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (withAvatar !== undefined) {
                localVarQueryParameter['with_avatar'] = withAvatar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMemberResult: async (sessionId: string, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sessionsGetMemberResult', 'sessionId', sessionId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('sessionsGetMemberResult', 'memberId', memberId)
            const localVarPath = `/sessions/sessions/{sessionId}/members/{memberId}/result`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMembers: async (sessionId: string, withAvatar?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('sessionsGetMembers', 'sessionId', sessionId)
            const localVarPath = `/sessions/sessions/{sessionId}/members`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            await setApiKeyToObject(localVarHeaderParameter, "apikey", configuration)

            if (withAvatar !== undefined) {
                localVarQueryParameter['with_avatar'] = withAvatar;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetDailyGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetDailyGameModeScores(appId, appModeId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {boolean} [validated] 
         * @param {number} [fetchExtraScores] 
         * @param {number} [killsGreaterThan] 
         * @param {string} [startDateTime] 
         * @param {string} [endDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetGameModeScoreRanked(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, validated?: boolean, fetchExtraScores?: number, killsGreaterThan?: number, startDateTime?: string, endDateTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetGameModeScoreRanked(appId, appModeId, numberOfScores, golf, validated, fetchExtraScores, killsGreaterThan, startDateTime, endDateTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetGameModeScores(appId, appModeId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {number} [threshold] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetGameModeScoresAll(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, threshold?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetGameModeScoresAll(appId, appModeId, numberOfScores, golf, threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetInfo(appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetInfo(appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [allowClosed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetSessions(appId: string, appModeId: string, allowClosed?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionWithId>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetSessions(appId, appModeId, allowClosed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetUsersDailyGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetUsersDailyGameModeScore(appId, appModeId, userId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetUsersGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetUsersGameModeScore(appId, appModeId, userId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetUsersGameModeScoreRanked(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetUsersGameModeScoreRanked(appId, appModeId, userId, numberOfScores, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsAppGetUsersGameModeScoresDaily(appId: string, appModeId: string, golf?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsAppGetUsersGameModeScoresDaily(appId, appModeId, golf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetMember(sessionId: string, memberId: string, withAvatar?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionsGetMember200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetMember(sessionId, memberId, withAvatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetMemberResult(sessionId: string, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetMemberResult(sessionId, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsGetMembers(sessionId: string, withAvatar?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionsGetMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsGetMembers(sessionId, withAvatar, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetDailyGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetDailyGameModeScores(appId, appModeId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {boolean} [validated] 
         * @param {number} [fetchExtraScores] 
         * @param {number} [killsGreaterThan] 
         * @param {string} [startDateTime] 
         * @param {string} [endDateTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScoreRanked(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, validated?: boolean, fetchExtraScores?: number, killsGreaterThan?: number, startDateTime?: string, endDateTime?: string, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.sessionsAppGetGameModeScoreRanked(appId, appModeId, numberOfScores, golf, validated, fetchExtraScores, killsGreaterThan, startDateTime, endDateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetGameModeScores(appId, appModeId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {number} [threshold] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetGameModeScoresAll(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, threshold?: number, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.sessionsAppGetGameModeScoresAll(appId, appModeId, numberOfScores, golf, threshold, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetInfo(appId: string, options?: any): AxiosPromise<AppInfo> {
            return localVarFp.sessionsAppGetInfo(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [allowClosed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetSessions(appId: string, appModeId: string, allowClosed?: boolean, options?: any): AxiosPromise<Array<SessionWithId>> {
            return localVarFp.sessionsAppGetSessions(appId, appModeId, allowClosed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersDailyGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetUsersDailyGameModeScore(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetUsersGameModeScore(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {string} userId 
         * @param {number} [numberOfScores] 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScoreRanked(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetUsersGameModeScoreRanked(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} appModeId 
         * @param {boolean} [golf] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsAppGetUsersGameModeScoresDaily(appId: string, appModeId: string, golf?: boolean, options?: any): AxiosPromise<Array<ScoreEntry>> {
            return localVarFp.sessionsAppGetUsersGameModeScoresDaily(appId, appModeId, golf, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMember(sessionId: string, memberId: string, withAvatar?: boolean, options?: any): AxiosPromise<SessionsGetMember200Response> {
            return localVarFp.sessionsGetMember(sessionId, memberId, withAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMemberResult(sessionId: string, memberId: string, options?: any): AxiosPromise<SessionResult> {
            return localVarFp.sessionsGetMemberResult(sessionId, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {boolean} [withAvatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsGetMembers(sessionId: string, withAvatar?: boolean, options?: any): AxiosPromise<SessionsGetMembers200Response> {
            return localVarFp.sessionsGetMembers(sessionId, withAvatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetDailyGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetDailyGameModeScores(appId, appModeId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {boolean} [validated] 
     * @param {number} [fetchExtraScores] 
     * @param {number} [killsGreaterThan] 
     * @param {string} [startDateTime] 
     * @param {string} [endDateTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetGameModeScoreRanked(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, validated?: boolean, fetchExtraScores?: number, killsGreaterThan?: number, startDateTime?: string, endDateTime?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetGameModeScoreRanked(appId, appModeId, numberOfScores, golf, validated, fetchExtraScores, killsGreaterThan, startDateTime, endDateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetGameModeScores(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetGameModeScores(appId, appModeId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {number} [threshold] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetGameModeScoresAll(appId: string, appModeId: string, numberOfScores?: number, golf?: boolean, threshold?: number, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetGameModeScoresAll(appId, appModeId, numberOfScores, golf, threshold, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetInfo(appId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetInfo(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {boolean} [allowClosed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetSessions(appId: string, appModeId: string, allowClosed?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetSessions(appId, appModeId, allowClosed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {string} userId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetUsersDailyGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetUsersDailyGameModeScore(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {string} userId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetUsersGameModeScore(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetUsersGameModeScore(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {string} userId 
     * @param {number} [numberOfScores] 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetUsersGameModeScoreRanked(appId: string, appModeId: string, userId: string, numberOfScores?: number, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetUsersGameModeScoreRanked(appId, appModeId, userId, numberOfScores, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appId 
     * @param {string} appModeId 
     * @param {boolean} [golf] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsAppGetUsersGameModeScoresDaily(appId: string, appModeId: string, golf?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsAppGetUsersGameModeScoresDaily(appId, appModeId, golf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} memberId 
     * @param {boolean} [withAvatar] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsGetMember(sessionId: string, memberId: string, withAvatar?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsGetMember(sessionId, memberId, withAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {string} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsGetMemberResult(sessionId: string, memberId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsGetMemberResult(sessionId, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {boolean} [withAvatar] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sessionsGetMembers(sessionId: string, withAvatar?: boolean, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).sessionsGetMembers(sessionId, withAvatar, options).then((request) => request(this.axios, this.basePath));
    }
}


